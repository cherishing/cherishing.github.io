<!DOCTYPE html><html lang="zh-EN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Jasmine"><meta name="description" content="简述本文主要讲解prototype,proto,constructor，instanceof各自的含义，构造函数，原型对象，实例之间的关系;描述出查找对象的属性的过程，原型链是如何构成的等等。"><meta name="keywords" content="Javascript,原型,原型链"><title>原型与原型链 · Jasmine</title><link rel="icon" href="/favicon.ico"><link rel="canonical" href="http://yoursite.com/2016/11/25/prototypeChain/"><link rel="stylesheet" href="/fonts/iconfont/iconfont.css"><link rel="stylesheet" href="/css/style.css"><script type="text/javascript">var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?Your baidu Analytics ID";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'Your Google Analytics ID', 'auto');
ga('send', 'pageview');</script></head><body><div id="main"><header><a href="/." class="logo">Jasmine</a><ul class="nav"><li class="nav-link"><a href="/" target="_self">Home</a></li><li class="nav-link"><a href="/archives/" target="_self">Archives</a></li><li class="nav-link"><a href="/tags/" target="_self">Tags</a></li><li class="nav-link"><a href="/about/" target="_self">About</a></li></ul></header><section id="container"><article class="post"><h1 class="post-title">原型与原型链</h1><span class="post-time">Nov 25, 2016</span><div id="sidebar" class="post-sidebar"><h3 class="heading">Contents</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简述"><span class="toc-text">简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型"><span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型（prototype）"><span class="toc-text">原型（prototype）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proto"><span class="toc-text">proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数、原型对象、实例之间的关系"><span class="toc-text">构造函数、原型对象、实例之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找对象的属性"><span class="toc-text">查找对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性和原型属性"><span class="toc-text">实例属性和原型属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断属性存在原型上还是实例上"><span class="toc-text">判断属性存在原型上还是实例上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li></ol></div><div class="post-content"><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>本文主要讲解 prototype, <strong>proto</strong>, constructor，instanceof各自的含义，构造函数，原型对象，实例之间的关系;描述出查找对象的属性的过程，原型链是如何构成的等等。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每周一次的前端分享，想了几天实在是不知道分享啥，正好最近在看面向对象，那就讲讲原型和原型链吧，在我不理解它们的时候，每次面试只要听到这几个词就吓得半死，简直是前端的恶魔。学东西就是这样吧，越是不理解的越害怕以为很难，其实只要认真去学去理解，没有自己想象的那么难。还是那句话，不懂的总有一天会懂，共勉。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h3><p><span style="color:red; font-weight:bolder;">原型（prototype）</span>：当一个函数被声明时，该函数下默认有一个属性：prototype，该属性的值是一个对象，当我们调用一个对象的属性或者方法的时候，如果该对象自身没有该属性或者方法，则会调用到该对象构造函数下的prototype的属性和方法。<br>简言之,prototype是声明一个函数的时候，在该函数下js创建的一个属性，这个属性指向函数的原型对象。</p>
<p>prototype的使用：通过某个构造函数创建出来的对象都可以公用的属性和方法。</p>
<p><strong>code:</strong>:<br>    function AA(){};<br>    var a = new AA();<br>    console.log(AA.prototype);  //Object,只有function定义的对象有该属性<br>    console.log(a.prototype);   //undefined,new操作符生成的对象没有该属性</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p><span style="color:red; font-weight:bolder;">constructor(构造函数)</span>：默认情况下，所有的原型对象都会自动获得一个constructor<br>属性，这个属性包含一个指向prototype属性所在函数的指针。<br><strong>code:</strong><br><img src="/img/protoChain/prototype_constructor01.png" alt="prototype"><br><br><br>输出结果：<br><img src="/img/protoChain/prototype_constructor02.png" alt="prototype"></p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p><span style="color: red; font-weight:bolder;"><strong>proto</strong></span>：当调用构造函<br>数创建一个新实例后，该实例的内部将包含一个指针（内部属性[[prototype]]），指向构造函数的原型对象。在ECMA-262第五版中这个指针叫做[[prototype]]。<br>虽然在脚本中没有标准的方式访问[[prototype]]，但浏览器在每个对象上都支持一个属性<br><strong>proto</strong>；而在其他实现中，该属性对脚本完全是不可见的。</p>
<p>栗子：</p>
<p><img src="/img/protoChain/prototype__proto__01.png" alt="__proto__"><br><br><br>输出结果：<br><img src="/img/protoChain/prototype__proto__02.png" alt="__proto__"></p>
<h3 id="构造函数、原型对象、实例之间的关系"><a href="#构造函数、原型对象、实例之间的关系" class="headerlink" title="构造函数、原型对象、实例之间的关系"></a>构造函数、原型对象、实例之间的关系</h3><p>栗子：</p>
<p><img src="/img/protoChain/prototype_01.png" alt="prototype"><br>解释：声明了一个构造函数Person，则该构造函数下会自动创建一个prototype属性；手动的给Person.prototype加上了name,sex,action等属性；实例化new Person(),生成实例对<br>象p1;实例对象p1的<strong>proto</strong>指向了Person的原型对象，而Person的原型对象的constructor指向了构造函数Person,但是Person构造函数的prototype又指回了Person的原型对象。<br>换句话说，实例和构造函数没有直接关系；这个连接存在与实例和构造函数的原型对象之间。因此：Person.prototype === p1.<strong>proto</strong>.<br><br><br>详细描述图：<br><img src="/img/protoChain/prototype_02.png" alt="prototype"></p>
<h3 id="查找对象的属性"><a href="#查找对象的属性" class="headerlink" title="查找对象的属性"></a>查找对象的属性</h3><p>当代码读取某个对象的某个属性的时候，都会执行一次搜索，目标是具有给定名字的属性，搜索首先会从对象实例本身开始。如果在实例中找到了给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象。</p>
<h4 id="实例属性和原型属性"><a href="#实例属性和原型属性" class="headerlink" title="实例属性和原型属性"></a>实例属性和原型属性</h4><p>1）code:</p>
<p><img src="/img/protoChain/prototype__prototype01.png" alt="属性"><br>在实例中添加一个属性，而该属性与实例原型中的一个属性同名，我们就在实例中创造该属性，而屏蔽原型中的该属性（阻止我们访问原型中的那个属性，而不会修改那个属性）。虽然我们可以通过实例访问保持在原型中的值，但却不能通过对象实例重写原型中的值。<br>2）code:<br><img src="/img/protoChain/prototype__prototype02.png" alt="属性"></p>
<p>即使将p1.name设置为null,也只会在实例中设置这个属性，而不会恢复其指向原型的连接。只有通过delete操作符删除实例属性，才能够重新访问原型中的属性。</p>
<p>效果如：<br><img src="/img/protoChain/prototype__prototype03.png" alt="属性"></p>
<h4 id="判断属性存在原型上还是实例上"><a href="#判断属性存在原型上还是实例上" class="headerlink" title="判断属性存在原型上还是实例上"></a>判断属性存在原型上还是实例上</h4><p>hasOwnPrototype():只在给定属性存在对象实例中，才会返回true。<br>in操作符：它会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<p>方法：<br><strong> function hasPrototypeProperty(object, name){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return !object.hasOwnPrototype(name) &amp;&amp; (name in object);<br>} </strong></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型对象也是普通的对象，并且也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链（prototype chain）</p>
<p><img src="/img/protoChain/prototype_chain01.png" alt="原型链"><br><br><br><br><br><img src="/img/protoChain/prototype_chain02.png" alt="原型链"></p>
</div></article><div class="tags"><a href="/tags/Javascript/">Javascript</a><a href="/tags/原型/">原型</a><a href="/tags/原型链/">原型链</a></div><div class="paginator"><a href="/2016/11/15/css3-shape/" class="next"><span>Next</span><i class="iconfont icon-right"></i></a></div><section id="comments"><div data-thread-key="http://yoursite.com/2016/11/25/prototypeChain/index.html" data-title="原型与原型链" data-url="http://yoursite.com/2016/11/25/prototypeChain/index.html" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name: "cherishing" };
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></section></section><footer><div class="copyright"><p class="power">Powered by <a href="https://hexo.io/">Hexo</a> and Theme by <a href="https://github.com/ahonn/hexo-theme-even"> Even</a></p><p class="since">&copy;2016<span class="heart"><i class="iconfont icon-heart"></i></span><span class="author">Jasmine</span></p></div><label id="back2top"><i class="iconfont icon-up"></i></label></footer></div><script src="/js/zepto.min.js"></script><script src="/js/theme.js"></script></body></html>